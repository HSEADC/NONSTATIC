<!doctype html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>Slime Mold</title><script defer="defer" src="/index.bd78d4c79a2db86a7a92.js"></script><script defer="defer" src="/articleItem.4df7e995e5e48a0489f4.js"></script><link href="/index.7a8156b14931dcfc3022.css" rel="stylesheet"><link href="/articleItem.b7dbe4d1bef0863ba9e4.css" rel="stylesheet"></head><body class="MG_Article"><div class="Q_ScrollBlur"><div style="position:absolute;inset:0;z-index:1;backdrop-filter:blur(0.125px);-webkit-backdrop-filter:blur(0.125px);mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 0%,rgba(0,0,0,1) 12.5%,rgba(0,0,0,1) 25%,rgba(0,0,0,0) 37.5%);-webkit-mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 0%,rgba(0,0,0,1) 12.5%,rgba(0,0,0,1) 25%,rgba(0,0,0,0) 37.5%);border-radius:0;pointer-events:none"></div><div style="position:absolute;inset:0;z-index:2;backdrop-filter:blur(0.25px);-webkit-backdrop-filter:blur(0.25px);mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 12.5%,rgba(0,0,0,1) 25%,rgba(0,0,0,1) 37.5%,rgba(0,0,0,0) 50%);-webkit-mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 12.5%,rgba(0,0,0,1) 25%,rgba(0,0,0,1) 37.5%,rgba(0,0,0,0) 50%);border-radius:0;pointer-events:none"></div><div style="position:absolute;inset:0;z-index:3;backdrop-filter:blur(0.5px);-webkit-backdrop-filter:blur(0.5px);mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 25%,rgba(0,0,0,1) 37.5%,rgba(0,0,0,1) 50%,rgba(0,0,0,0) 62.5%);-webkit-mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 25%,rgba(0,0,0,1) 37.5%,rgba(0,0,0,1) 50%,rgba(0,0,0,0) 62.5%);border-radius:0;pointer-events:none"></div><div style="position:absolute;inset:0;z-index:4;backdrop-filter:blur(1px);-webkit-backdrop-filter:blur(1px);mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 37.5%,rgba(0,0,0,1) 50%,rgba(0,0,0,1) 62.5%,rgba(0,0,0,0) 75%);-webkit-mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 37.5%,rgba(0,0,0,1) 50%,rgba(0,0,0,1) 62.5%,rgba(0,0,0,0) 75%);border-radius:0;pointer-events:none"></div><div style="position:absolute;inset:0;z-index:5;backdrop-filter:blur(2px);-webkit-backdrop-filter:blur(2px);mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 50%,rgba(0,0,0,1) 62.5%,rgba(0,0,0,1) 75%,rgba(0,0,0,0) 87.5%);-webkit-mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 50%,rgba(0,0,0,1) 62.5%,rgba(0,0,0,1) 75%,rgba(0,0,0,0) 87.5%);border-radius:0;pointer-events:none"></div><div style="position:absolute;inset:0;z-index:6;backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 62.5%,rgba(0,0,0,1) 75%,rgba(0,0,0,1) 87.5%,rgba(0,0,0,0) 100%);-webkit-mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 62.5%,rgba(0,0,0,1) 75%,rgba(0,0,0,1) 87.5%,rgba(0,0,0,0) 100%);border-radius:0;pointer-events:none"></div><div style="position:absolute;inset:0;z-index:7;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 75%,rgba(0,0,0,1) 87.5%,rgba(0,0,0,1) 100%);-webkit-mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 75%,rgba(0,0,0,1) 87.5%,rgba(0,0,0,1) 100%);border-radius:0;pointer-events:none"></div><div style="position:absolute;inset:0;z-index:8;backdrop-filter:blur(16px);-webkit-backdrop-filter:blur(16px);mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 87.5%,rgba(0,0,0,1) 100%);-webkit-mask-image:linear-gradient(to bottom,rgba(0,0,0,0) 87.5%,rgba(0,0,0,1) 100%);border-radius:0;pointer-events:none"></div></div><nav class="O_NavBar"><div class="W_MenuWithLogo"><a href="../index.html" class="A_MiniLogo Light"></a><div class="C_MenuButtons"><a href="../art-projects.html" class="A_MenuButton">Галерея</a> <a href="../articles.html" class="A_MenuButton Selected">Статьи</a> <a href="../error404.html" class="A_MenuButton">Код</a></div><div class="A_Burger"><div class="Q_Burger"></div></div></div><div class="C_MenuButtons Mobile"><a href="../art-projects.html" class="A_MenuButton">Галерея</a> <a href="../articles.html" class="A_MenuButton Selected">Статьи</a> <a href="../art-projects.html" class="A_MenuButton">Код</a></div><div id="react-search-root"></div></nav><div class="MO_Article"><a class="A_Back Back Articles" href="../articles.html"><div class="Q_ButtonIcon Arrow"></div>Назад</a><div class="SO_VideoPreview Desktop"><canvas class="A_ElectricCanvas" width="728" height="644"></canvas><video class="A_VideoPreview Desktop" src="/4306fe1cd1edb7b57f28.mp4" autoplay="" muted="" loop="" playsinline=""></video><a href="" class="A_Button">Смотреть видос</a><div class="O_PopUp Opened"><div class="M_PopupOpenLine"><div class="A_Description Important">Важная инфа</div><div class="Q_PopUpIcon Opened"></div></div><div class="A_Description">Этот тутор ты можешь повторить в нашей песочнице</div><div class="A_Description Important">Материалы</div><div class="C_PopUpMateirals"><div class="A_Description">Проджект файл</div></div></div></div><div class="SO_Article"><h2 class="A_H2 Mobile">Симуляция плесени</h2><div class="O_ArticleDemo"><div class="W_Article"><video class="A_ArticlePreview" src="/4306fe1cd1edb7b57f28.mp4" autoplay="" muted="" loop="" playsinline=""></video><div class="C_Tags"><div class="A_Tag">Тутор</div><div class="A_Tag">Продолжающим</div><div class="A_Tag">Код</div></div></div><div class="SO_VideoPreview Mobile"><canvas class="A_ElectricCanvas" width="728" height="644"></canvas><a href="" class="A_Button">Смотреть видос</a><div class="O_PopUp Closed Mobile"><div class="M_PopupOpenLine"><h4 class="A_Label Important">Важная инфа</h4><div class="Q_PopUpIcon Closed"></div></div><div class="A_Description Closed">Этот тутор ты можешь повторить в нашей песочнице</div><h4 class="A_Label Important Closed">Материалы</h4><div class="C_PopUpMateirals Closed"><div class="A_Description Closed">Проджект файл</div></div></div></div><div class="W_ArticleDemoText"><h2 class="A_H2">Симуляция плесени</h2><div class="M_Paragraph"><div class="A_Paragraph ArticleMain">В этом туториале мы разберем симуляцию плесени. Для нее мы создадим большое количество точек, которые будут на основе сенсоров приближаться друг к другу, формируя разные паттерны.</div><div class="M_ArticleStats"><div class="A_Description">Лиза Цимайло</div><div class="A_Description">16/02/20025</div><div class="Q_AvatarIMG Dasha"></div></div></div></div></div><img class="A_VideoPreview Tablet" src="/4306fe1cd1edb7b57f28.mp4"><div class="W_ParagraphWithTitle"><h3 class="A_H3">Алгоритм</h3><div class="M_Paragraph"><div class="A_Paragraph">Сначала создадим класс Mold, внутри которого будет точка, которая двигается в рандомном направлении. Нам понадобится 3 метода: constructor(), display() и update(). В constructor() пропишем базовое местоположение точки, ее радиус (для начала, напишем 0.5), направление в градусах. В update() будем менять координаты точки, а в display() сделаем ей отображение в виде белого круга без контура.</div><div class="A_Description Right">Весь туториал построен на принципе ООП - объектно-ориентированного программирования. Так, в JS базовым методом, который вызывается при инициализации  класса, является constructor(), а к свойствам мы обращаемся через ключевое слово this.</div></div></div><div class="M_Paragraph"><div class="A_Description">Шаг 1</div><div class="A_Paragraph">В update() будем менять координаты точки следующим образом: к горизонтальному смещению будем прибавлять косинус направления, а к вертикальному - синус, согласно принципам тригонометрии.</div><div class="A_Description Right">Например, если мы поставим heading = 0, все точки пойдут вправо, а если поставим heading = 90, они пойдут вниз (в 5p.js изначально вектор Y направлен вниз, а не вверх)</div></div><div class="M_Paragraph"><div class="A_Description">Скопируй</div><div class="A_NodeBox"><pre><code class="language-javascript">class Mold {
        constructor() {
          this.x = random(width); 
          this.y = random(height); 
          this.r = 0.5; 
          this.heading = random(360); 
        }
        update() {
          this.x += cos(this.heading)
          this.y += sin(this.heading)
        }
      ​
        display() {
          noStroke()
          fill(255)
          ellipse(this.x, this.y, this.r)
        }
      }</code></pre></div></div><div class="M_Paragraph"><div class="A_Description">Шаг 2</div><div class="A_Paragraph">Сейчас мы ничего не видим, потому что не добавили draw() и setup(). В setup() cоздадим кэнвас, переключим angleMode(DEGREES) (изначально он в радианах), создадим новый объект и присвоим ему класс Mold. В draw() будем обращаться к 2 методам класса - обновлять и отображать нашу точку. Мы также будем наслаивать фреймы друг на друга, чтобы у точек было эхо, этого можно добиться, добавив черному фону полупрозрачность (0, 5).</div><div class="A_Description Right">При инилизации класса в JS, мы прописываем ключевое слово new</div></div><div class="M_Paragraph"><div class="A_Description">Скопируй</div><div class="A_NodeBox"><pre><code class="language-javascript">class Mold {
        ...
        }
        ​
        ​
        function setup() {
          createCanvas(400, 400)
          angleMode(DEGREES)
          m = new Mold()
        }
        ​
        function draw() {
          background(0, 5)
          m.update()
          m.display()
        }</code></pre></div></div><div class="M_Paragraph"><div class="A_Description">Шаг 3</div><div class="A_Paragraph">Создадим несколько таких точек через цикл. Создадим пустой список, назовем его molds и в переменную n поместим количество точек, которые нас интересуют. Допустим, 400. Теперь в цикле создадим n-ое количество точек и добавих их в список, чтобы потом пройтись по каждому элементу в списке и применить к нему display() и update()</div></div><div class="M_Paragraph"><div class="A_Description">Скопируй</div><div class="A_NodeBox"><pre><code class="language-javascript">class Mold {
      ...
      }
      ​
      let molds = []
      let n = 400
      ​
      ​
      function setup() {
        createCanvas(400, 400)
        angleMode(DEGREES)
        for (let i = 0; i &lt; n; i++) {
        molds.push(new Mold())
        }
      }
      ​
      function draw() {
        background(0, 5)
        for (let mold of molds) {
        mold.display();
        mold.update()
       }
      }</code></pre></div></div><div class="M_Paragraph"><div class="A_Description">Шаг 4</div><div class="A_Paragraph">Добавим сенсоры. В constructor() добавим sensorAngle (угол, на котором расположены сенсоры) и sensorDist (расстояние до них). Суть сенсоров в том, чтобы смещать положение точки в сторону других объектов. Т.к. объекты оставляют за собой белый путь, нам нужно находить самые светлые участки и стремиться к ним. Добавим в класс метод getPixelValue(). Будем находить координаты сенсоров и возвращать их яркость.</div></div><div class="M_Paragraph"><div class="A_Description">Шаг 5</div><div class="A_Paragraph">В методе getPixelValue() создадим 2 новые переменные - sx и sy. Чтобы найти координаты сенсоров, нам нужно просто к координате точек добавить направление вектора (this.heading) и расстояние, на котором расположены сенсоры от точек (sensorDist)</div></div><div class="M_Paragraph"><div class="A_Description">Скопируй</div><div class="A_NodeBox"><pre><code class="language-javascript">class Mold {
        constructor() {
          this.x = random(width)
          this.y = random(height)
          this.r = 0.5
          this.heading = random(360)
          this.sensorDist = 10
          this.sensorAngle = 45
        }
        update() {
        ...
        }
        getPixelValue(angle) {
          let sx = this.x + this.sensorDist * cos(angle)
          let sy = this.y + this.sensorDist * sin(angle)
          return brightness(get(sx, sy))
        }
      }
      ​
      let molds = []
      let n = 400
      ​
      ​
      function setup() {
      ...
      }
      ​
      function draw() {
      ...
      }</code></pre></div></div><div class="M_Paragraph"><div class="A_Description">Шаг 6</div><div class="A_Paragraph">Создадим новый метод checkSensors(). Т.к. нам нужны 3 сенсора, создаем 3 переменные - f, l и r. Для каждого нужно узнать значение яркости, поэтому мы вызываем метод getPixelValue() для каждого из них. Для переднего сенсора угол тот же, что в this.heading, для левого - из изначального вектора вычитаем поворот сенсора, а для правого - прибавляем.</div></div><div class="M_Paragraph"><div class="A_Description">Скопируй</div><div class="A_NodeBox"><pre><code class="language-javascript">class Mold {
          constructor() {
          ...
          }
          update() {
          ... 
          }
          checkSensors() {
            let f = this.getPixelValue(this.heading)
            let l = this.getPixelValue(this.heading - this.sensorAngle)
            let r = this.getPixelValue(this.heading + this.sensorAngle)
          }
          getPixelValue(angle) {
          ...
          }
          display() {
          ...
          }
        }
        ​
        let molds = []
        let n = 4000
        ​
        function setup() {
          ...
        }
        ​
        function draw() {
          ...
        }</code></pre></div></div><div class="M_Paragraph"><div class="A_Description">Шаг 7</div><div class="A_Paragraph">Осталось изменять направление, взависимости от значений сенсоров. Если один из боковых сенсоров светлее переднего, мы делаем поворот. Если левый светлее - налево, если правый - направо.</div></div><div class="M_Paragraph"><div class="A_Description">Скопируй</div><div class="A_NodeBox"><pre><code class="language-javascript">class Mold {
          constructor() {
          ...
          }
          update() {
          ... 
          }
          checkSensors() {
            let f = this.getPixelValue(this.heading)
            let l = this.getPixelValue(this.heading - this.sensorAngle)
            let r = this.getPixelValue(this.heading + this.sensorAngle)
        ​
            if (f &lt; l || f &lt; r) {
               this.heading += (l > r) ? -45 : 45;
            }
          }
        ​
          getPixelValue(angle) {
          ...
          }
          display() {
          ...
          }
        }
        ​
        let molds = []
        let n = 4000
        ​
        function setup() {
          ...
        }
        ​
        function draw() {
          ...
        }</code></pre></div></div><div class="M_Paragraph"><div class="A_Description">Шаг 8</div><div class="A_Paragraph">Мы почти закончили! Но сейчас плесень распространяется в рамках нашего кэнваса. Хочется, чтобы она выходила и за его границы. Для этого добавим в координаты точки и сенсоров принцип тороидального пространства. Подробнее об этом можно прочитать здесь. Для этого используем формулу (координаты + ширина) % ширина.</div><div class="A_Description Right">Тороидальное пространство бесконечно, поэтому нам нужно, чтобы точки не исчезали, а появлялись с обратной стороны. Сделать это можно через остаток от деления. Если координаты выходят за границы кэнваса, они сбрасываются.</div></div><div class="M_Paragraph"><div class="A_Description">Скопируй</div><div class="A_NodeBox"><pre><code class="language-javascript">class Mold {
          constructor() {
            this.x = random(width)
            this.y = random(height)
            this.r = 0.5
            this.heading = random(360)
            this.sensorAngle = 45
            this.sensorDist = 10
          }
        
          update() {
            this.x = (this.x + cos(this.heading) + width) % width
            this.y = (this.y + sin(this.heading) + height) % height
            this.checkSensors()
          }
        
          checkSensors() {
            let f = this.getPixelValue(this.heading)
            let l = this.getPixelValue(this.heading - this.sensorAngle)
            let r = this.getPixelValue(this.heading + this.sensorAngle)
            if (f &lt; l || f &lt; r) {
              this.heading += l > r ? -45 : 45
            }
          }
        
          getPixelValue(angle) {
            let sx = (this.x + this.sensorDist * cos(angle) + width) % width
            let sy = (this.y + this.sensorDist * sin(angle) + height) % height
            return brightness(get(sx, sy))
          }
        
          display() {
            noStroke()
            fill(255)
            ellipse(this.x, this.y, this.r)
          }
        ​
        let molds = []
        let n = 4000
        
        function setup() {
          createCanvas(400, 400)
          angleMode(DEGREES)
          for (let i = 0; i &lt; n; i++) {
          molds.push(new Mold())
          }
        }
        
        function draw() {
          background(0, 5)
          for (let mold of molds) {
          mold.display();
          mold.update()
         }
        }</code></pre></div></div><div class="W_ParagraphWithTitle"><h3 class="A_H3">Кастомизация</h3><div class="M_Paragraph"><div class="A_Paragraph">Паттерн плесени можно изменять через угол поворота сенсоров. Так, можно от ретикулярной структуры (ячейковидной) прийти к островной (когда объекты образуют отдельные кластеры). Можно изменять точку их спавна, расстояние, на котором расположены сенсоры и т.д.</div></div></div><div class="W_ParagraphWithTitle"><h3 class="A_H3">А вот что получилось у редакции</h3><img src="/images/redaction1.ff9e44801ebabb126f56.png" alt="" class="A_GalleryRedactionContainer"><div class="C_RedactionPreview"><img src="/images/redaction1.ff9e44801ebabb126f56.png" alt="" class="A_Redaction"> <img src="/images/redaction2.b69eab9548a083a6496e.png" alt="" class="A_Redaction"> <img src="/images/redaction3.3fbe3a60edf3c9d663d8.png" alt="" class="A_Redaction"></div></div></div></div><div class="W_ArticleRecommendation"><h2 class="A_H2">Похожие статьи</h2><div class="C_ArticlesRecommendation"><div class="O_Card" id="article-card-2" data-category="nodeProgramme beginner tutorial"><a class="M_ArticlePreviewLink" href="FluffyTheNoise.html"><div class="C_Tags Preview"><div class="A_Tag">Нодовые</div><div class="A_Tag">Новичок</div><div class="A_Tag">Туториал</div></div><img class="A_ArticlePreviewIMG" src="/images/fluffyTheNoisePreview.551a29ef4ddbc6897a63.png"></a><h4 class="A_Label Important">Пушистый шум</h4><canvas class="A_ElectricCanvas" width="728" height="644"></canvas></div><div class="O_Card" id="article-card-2" data-category="nodeProgramme beginner tutorial"><a class="M_ArticlePreviewLink" href="pointCloud.html"><div class="C_Tags Preview"><div class="A_Tag">Нодовые</div><div class="A_Tag">Новичок</div><div class="A_Tag">Туториал</div></div><img class="A_ArticlePreviewIMG" src="/images/pointCloudPreview.51c0b2fa2edbfa03d0ef.png"></a><h4 class="A_Label Important">Облако точек</h4><canvas class="A_ElectricCanvas" width="728" height="644"></canvas></div><div class="O_Card" id="article-card-2" data-category="code beginner tutorial"><a class="M_ArticlePreviewLink" href="slimeMold.html"><div class="C_Tags Preview"><div class="A_Tag">Нодовые</div><div class="A_Tag">Новичок</div><div class="A_Tag">Туториал</div></div><img class="A_ArticlePreviewIMG" src="/images/slimeMoldPreview.9f6695cdabf10db05103.png"></a><h4 class="A_Label Important">Симуляция плесени</h4><canvas class="A_ElectricCanvas" width="728" height="644"></canvas></div></div></div><div class="O_Footer Light"><div class="W_FooterSlogan"><div class="M_FooterSlogan"><h3>Шарим за генератив</h3><p class="A_Description">Медиа 2024-2025</p></div><div class="A_Logo"></div></div><div class="C_FooterMenu"><div class="W_FooterMenuTable"><h4 class="A_Label Accent">Потерял?</h4><div class="C_Categories"><a class="A_Description">Статьи</a> <a class="A_Description">Галерея</a> <a class="A_Description">Песочница</a></div></div><div class="W_FooterMenuTable"><h4 class="A_Label Accent">Го щитпост?</h4><div class="C_Categories"><a class="A_Description">Телеграмм</a> <a class="A_Description">Юпуп</a> <a class="A_Description">Вк</a></div></div></div></div></body></html>